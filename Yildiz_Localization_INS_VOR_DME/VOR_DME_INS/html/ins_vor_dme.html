<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>ins_vor_dme</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-05-29">
<meta name="DC.source" content="ins_vor_dme.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#3">ZUPT ALGORITHM</a>
</li>
<li>
<a href="#4">PREALLOCATION</a>
</li>
<li>
<a href="#5">INITIAL VALUES AT INS TIME = 1</a>
</li>
<li>
<a href="#6">INITIALIZATION OF KALMAN FILTER MATRICES</a>
</li>
<li>
<a href="#7">INS (IMU) TIME IS THE MASTER CLOCK</a>
</li>
<li>
<a href="#9">INERTIAL NAVIGATION SYSTEM (INS)</a>
</li>
<li>
<a href="#10">ZUPT DETECTION ALGORITHM</a>
</li>
<li>
<a href="#11">KALMAN FILTER UPDATE</a>
</li>
<li>
<a href="#13">MEASUREMENTS</a>
</li>
<li>
<a href="#14">KALMAN FILTER</a>
</li>
<li>
<a href="#15">OBSERVABILITY</a>
</li>
<li>
<a href="#16">INS/vor_dme CORRECTIONS</a>
</li>
<li>
<a href="#19">Summary from INS/vor_dme integration</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="keyword">function</span> [nav_e] = ins_vor_dme(imu, vor_dme, att_mode)
</pre>
<pre class="codeinput">
<span class="comment">% ins_vor_dme: loosely-coupled integrated navigation system.</span>
<span class="comment">%</span>
<span class="comment">% ins_vor_dme integrates IMU and vor_dme measurements by using an Extended Kalman filter.</span>
<span class="comment">%</span>
<span class="comment">% INPUT</span>
<span class="comment">%   imu, IMU data structure.</span>
<span class="comment">%         t: Ix1 time vector (seconds).</span>
<span class="comment">%        fb: Ix3 accelerations vector in body frame XYZ (m/s^2).</span>
<span class="comment">%        wb: Ix3 turn rates vector in body frame XYZ (radians/s).</span>
<span class="comment">%       arw: 1x3 angle random walks (rad/s/root-Hz).</span>
<span class="comment">%       vrw: 1x3 velocity random walks (m/s^2/root-Hz).</span>
<span class="comment">%     g_std: 1x3 gyros standard deviations (radians/s).</span>
<span class="comment">%     a_std: 1x3 accrs standard deviations (m/s^2).</span>
<span class="comment">%    gb_sta: 1x3 gyros static biases or turn-on biases (radians/s).</span>
<span class="comment">%    ab_sta: 1x3 accrs static biases or turn-on biases (m/s^2).</span>
<span class="comment">%    gb_dyn: 1x3 gyros dynamic biases or bias instabilities (radians/s).</span>
<span class="comment">%    ab_dyn: 1x3 accrs dynamic biases or bias instabilities (m/s^2).</span>
<span class="comment">%   gb_corr: 1x3 gyros correlation times (seconds).</span>
<span class="comment">%   ab_corr: 1x3 accrs correlation times (seconds).</span>
<span class="comment">%    gb_psd: 1x3 gyros dynamic biases root-PSD (rad/s/root-Hz).</span>
<span class="comment">%    ab_psd: 1x3 accrs dynamic biases root-PSD (m/s^2/root-Hz);</span>
<span class="comment">%      freq: 1x1 sampling frequency (Hz).</span>
<span class="comment">% ini_align: 1x3 initial attitude at t(1).</span>
<span class="comment">% ini_align_err: 1x3 initial attitude errors at t(1).</span>
<span class="comment">%</span>
<span class="comment">%   vor_dme, VOR/DME data structure.</span>
<span class="comment">%         t: Gx1 time vector (seconds).</span>
<span class="comment">%       lat: Gx1 latitude (radians).</span>
<span class="comment">%       lon: Gx1 longitude (radians).</span>
<span class="comment">%         h: Gx1 altitude (m).</span>
<span class="comment">%       vel: Gx3 NED velocities (m/s).</span>
<span class="comment">%       std: 1x3 position standard deviations (rad, rad, m).</span>
<span class="comment">%      stdm: 1x3 position standard deviations (m, m, m).</span>
<span class="comment">%      stdv: 1x3 velocity standard deviations (m/s).</span>
<span class="comment">%      larm: 3x1 lever arm from IMU to vor_dme antenna (x-fwd, y-right, z-down) (m).</span>
<span class="comment">%      freq: 1x1 sampling frequency (Hz).</span>
<span class="comment">%   zupt_th: 1x1 ZUPT threshold (m/s).</span>
<span class="comment">%  zupt_win: 1x1 ZUPT time window (seconds).</span>
<span class="comment">%       eps: 1x1 time interval to compare current IMU time to current vor_dme time vector (s).</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%	vor_dme, vor_dme data structure.</span>
<span class="comment">%         t: Gx1 time vector (seconds).</span>
<span class="comment">%       lat: Gx1 latitude (radians).</span>
<span class="comment">%       lon: Gx1 longitude (radians).</span>
<span class="comment">%         h: Gx1 altitude (m).</span>
<span class="comment">%       vel: Gx3 NED velocities (m/s).</span>
<span class="comment">%       std: 1x3 position standard deviations (rad, rad, m).</span>
<span class="comment">%      stdm: 1x3 position standard deviations (m, m, m).</span>
<span class="comment">%      stdv: 1x3 velocity standard deviations (m/s).</span>
<span class="comment">%      larm: 3x1 lever arm from IMU to vor_dme antenna (x-fwd, y-right, z-down) (m).</span>
<span class="comment">%      freq: 1x1 sampling frequency (Hz).</span>
<span class="comment">%   zupt_th: 1x1 ZUPT threshold (m/s).</span>
<span class="comment">%  zupt_win: 1x1 ZUPT time window (seconds).</span>
<span class="comment">%       eps: 1x1 time interval to compare current IMU time to current vor_dme time vector (s).</span>
<span class="comment">%</span>
<span class="comment">%  att_mode: attitude mode string.</span>
<span class="comment">%      'quaternion': attitude updated in quaternion format. Default value.</span>
<span class="comment">%             'dcm': attitude updated in Direct Cosine Matrix format.</span>
<span class="comment">%</span>
<span class="comment">% OUTPUT</span>
<span class="comment">%   nav_e, INS/vor_dme navigation estimates data structure.</span>
<span class="comment">%         t: Ix1 INS time vector (seconds).</span>
<span class="comment">%        tg: Gx1 vor_dme time vector, when Kalman filter was executed (seconds).</span>
<span class="comment">%      roll: Ix1 roll (radians).</span>
<span class="comment">%     pitch: Ix1 pitch (radians).</span>
<span class="comment">%       yaw: Ix1 yaw (radians).</span>
<span class="comment">%       vel: Ix3 NED velocities (m/s).</span>
<span class="comment">%       lat: Ix1 latitude (radians).</span>
<span class="comment">%       lon: Ix1 longitude (radians).</span>
<span class="comment">%         h: Ix1 altitude (m).</span>
<span class="comment">%        xi: Gxn Kalman filter a priori states.</span>
<span class="comment">%        xp: Gxn Kalman filter a posteriori states.</span>
<span class="comment">%         z: Gxr INS/vor_dme measurements</span>
<span class="comment">%         v: Gxr Kalman filter innovations.</span>
<span class="comment">%         b: Gxr Kalman filter biases compensations, [gb_dyn ab_dyn].</span>
<span class="comment">%         A: Gxn^2 Kalman filter transition-state matrices, one matrix per</span>
<span class="comment">%            row ordered by columns.</span>
<span class="comment">%        Pp: Gxn^2 Kalman filter a posteriori covariance matrices, one</span>
<span class="comment">%         matrix per row ordered by columns.</span>
<span class="comment">%        Pi: Gxn^2 Kalman filter a priori covariance matrices, one matrix</span>
<span class="comment">%            per row ordered by columns.</span>
<span class="comment">%         K: Gx(n*r) Kalman gain matrices</span>
<span class="comment">%         S: Gxr^2 Innovation matrices</span>
<span class="comment">%        ob: Gx1 Number of observable states after each vor_dme data arriving</span>



<span class="keyword">if</span> nargin &lt; 3, att_mode  = <span class="string">'quaternion'</span>; <span class="keyword">end</span>
</pre>
<h2 id="3">ZUPT ALGORITHM</h2>
<pre class="codeinput">zupt_flag = false;
</pre>
<h2 id="4">PREALLOCATION</h2>
<pre class="codeinput">
<span class="comment">% Kalman filter dimensions</span>
n = 15; <span class="comment">% number of states</span>
r = 6;  <span class="comment">% number of sensors</span>
<span class="comment">% q = 12; % number of inputs</span>

<span class="comment">% Constant matrices</span>
I = eye(3);
O = zeros(3);

<span class="comment">% Length of INS time vector</span>
LI = length(imu.t);

<span class="comment">% Length of vor_dme time vector</span>
LG = length(vor_dme.t);

<span class="comment">% Preallocation of attitude vectors</span>
roll_e  = zeros (LI, 1);
pitch_e = zeros (LI, 1);
yaw_e   = zeros (LI, 1);

<span class="comment">% Preallocation of velocity vector</span>
vel_e   = zeros (LI, 3);

<span class="comment">% Preallocation of gravity vector</span>
gn_e   = zeros (LI, 3);

<span class="comment">% Preallocation of position vectors</span>
lat_e    = zeros (LI, 1);
lon_e    = zeros (LI, 1);
h_e      = zeros (LI, 1);

<span class="comment">% Preallocation of Kalman filter matrices for later performance analysis</span>
xi = zeros(LG, n);      <span class="comment">% Evolution of Kalman filter a priori states</span>
xp = zeros(LG, n);      <span class="comment">% Evolution of Kalman filter a posteriori states</span>
z = zeros(LG, r);       <span class="comment">% INS/vor_dme measurements</span>
v = zeros(LG, r);       <span class="comment">% Kalman filter innovations</span>

A  = zeros(LG, n^2);    <span class="comment">% Transition-state matrices</span>
Pi = zeros(LG, n^2);    <span class="comment">% A priori covariance matrices</span>
Pp = zeros(LG, n^2);    <span class="comment">% A posteriori covariance matrices</span>
K  = zeros(LG, n*r);    <span class="comment">% Kalman gain matrices</span>
S  = zeros(LG, r^2);    <span class="comment">% Innovation matrices</span>
ob = zeros(LG, 1);      <span class="comment">% Number of observable states at each vor_dme data arriving</span>

b = zeros(LG, r);       <span class="comment">% Biases compensantions after Kalman filter correction</span>
</pre>
<pre class="codeoutput error">Not enough input arguments.

Error in ins_vor_dme (line 108)
LI = length(imu.t);
</pre>
<h2 id="5">INITIAL VALUES AT INS TIME = 1</h2>
<pre class="codeinput">
<span class="comment">% Initial attitude</span>
roll_e(1)  = imu.ini_align(1);
pitch_e(1) = imu.ini_align(2);
yaw_e(1)   = imu.ini_align(3);
DCMnb = euler2dcm([roll_e(1); pitch_e(1); yaw_e(1);]);
DCMbn = DCMnb';
qua   = euler2qua([roll_e(1) pitch_e(1) yaw_e(1)]);

<span class="comment">% Initial velocity</span>
vel_e(1,:) = vor_dme.vel(1,:);

<span class="comment">% Initial position</span>
lat_e(1) = vor_dme.lat(1);
lon_e(1) = vor_dme.lon(1);
h_e(1)   = vor_dme.h(1);

<span class="comment">% Initial dynamic biases</span>
gb_dyn = imu.gb_dyn';
ab_dyn = imu.ab_dyn';

<span class="comment">% Turn-rates update with both updated velocity and position</span>
omega_ie_n = earth_rate(lat_e(1));
omega_en_n = transport_rate(lat_e(1), vel_e(1,1), vel_e(1,2), h_e(1));

<span class="comment">% Gravity update</span>
gn_e(1,:) = gravity(lat_e(1), h_e(1));
</pre>
<h2 id="6">INITIALIZATION OF KALMAN FILTER MATRICES</h2>
<pre class="codeinput">
<span class="comment">% Prior estimates</span>
kf.xi = [ zeros(1,9), imu.gb_dyn, imu.ab_dyn ]';  <span class="comment">% Error vector state</span>
kf.Pi = diag([imu.ini_align_err, vor_dme.stdv, vor_dme.std, imu.gb_dyn, imu.ab_dyn].^2);

kf.Q  = diag([imu.arw, imu.vrw, imu.gb_psd, imu.ab_psd].^2);
<span class="comment">%kf.Q  = diag([imu.arw, imu.vrw, [0 0 0], [0 0 0]].^2);</span>

fn = DCMbn * (imu.fb(1,:)' - ab_dyn - imu.ab_sta');
wn = DCMbn * (imu.wb(1,:)' - gb_dyn - imu.gb_sta');

<span class="comment">% Vector to update matrix F</span>
upd = [vor_dme.vel(1,:) vor_dme.lat(1) vor_dme.h(1) fn' wn'];

<span class="comment">% Update matrices F and G</span>
[kf.F, kf.G] = F_update(upd, DCMbn, imu);

[RM,RN] = radius(vor_dme.lat(1));
Tpr = diag([(RM + vor_dme.h(1)), (RN + vor_dme.h(1)) * cos(vor_dme.lat(1)), -1]);  <span class="comment">% radians-to-meters</span>

<span class="comment">% Update matrix H</span>
kf.H = [ O I O O O ; O O Tpr O O ; ];
kf.R = diag([vor_dme.stdv vor_dme.stdm]).^2;
kf.z = [ vor_dme.stdv, vor_dme.stdm ]';

<span class="comment">% Propagate prior estimates to get xp(1) and Pp(1)</span>
kf = kf_update( kf );

<span class="comment">% Initial matrices for Kalman filter performance analysis</span>
xi(1,:) = kf.xi';
xp(1,:) = kf.xp';
Pi(1,:) = reshape(kf.Pi, 1, n^2);
Pp(1,:) = reshape(kf.Pp, 1, n^2);
K(1,:)  = reshape(kf.K, 1, n*r);
S(1,:)  = reshape(kf.S, 1, r^2);
v(1,:)  = kf.v';
z(1,:)  = kf.z';
b(1,:) = [gb_dyn', ab_dyn'];
</pre>
<h2 id="7">INS (IMU) TIME IS THE MASTER CLOCK</h2>
<pre class="codeinput">
<span class="keyword">for</span> i = 2:LI
</pre>
<h2 id="9">INERTIAL NAVIGATION SYSTEM (INS)</h2>
<pre class="codeinput">    <span class="comment">% Print a dot on console every 10,000 INS executions</span>
    <span class="keyword">if</span> (mod(i,10000) == 0), fprintf(<span class="string">'. '</span>);  <span class="keyword">end</span>
    <span class="comment">% Print a return on console every 200,000 INS executions</span>
    <span class="keyword">if</span> (mod(i,200000) == 0), fprintf(<span class="string">'\n'</span>); <span class="keyword">end</span>

    <span class="comment">% IMU sampling interval</span>
    dti = imu.t(i) - imu.t(i-1);

    <span class="comment">% Inertial sensors corrected with a posteriori KF biases estimation and</span>
    <span class="comment">% deterministic static biases</span>
    wb_corrected = imu.wb(i,:)' - gb_dyn - imu.gb_sta';
    fb_corrected = imu.fb(i,:)' - ab_dyn - imu.ab_sta';
    fn = DCMbn * fb_corrected;
    wn = DCMbn * wb_corrected;


    <span class="comment">% Velocity update</span>
    vel = vel_update(fn, vel_e(i-1,:), omega_ie_n, omega_en_n, gn_e(i-1,:)', dti);
    vel_e (i,:) = vel;

    <span class="comment">% Position update</span>
    pos = double(pos_update([lat_e(i-1) lon_e(i-1) h_e(i-1)], vel_e(i,:), dti));
    lat_e(i) = double(pos(1));
    lon_e(i) = double(pos(2));
    h_e(i)   = double(pos(3));

    <span class="comment">% Turn-rates update with both updated velocity and position</span>
    omega_ie_n = earth_rate(lat_e(i));
    omega_en_n = transport_rate(lat_e(i), vel_e(i,1), vel_e(i,2), h_e(i));

    <span class="comment">% Gravity update</span>
    gn_e(i,:) = gravity(lat_e(i), h_e(i));

    <span class="comment">% Attitude update</span>
    [qua, DCMbn, euler] = att_update(wb_corrected, DCMbn, qua, <span class="keyword">...</span>
        omega_ie_n, omega_en_n, dti, att_mode);
    roll_e(i) = euler(1);
    pitch_e(i)= euler(2);
    yaw_e(i)  = euler(3);
</pre>
<h2 id="10">ZUPT DETECTION ALGORITHM</h2>
<pre class="codeinput">    idz = floor( vor_dme.zupt_win / dti ); <span class="comment">% Index to set ZUPT window time</span>

    <span class="keyword">if</span> ( i &gt; idz )

        <span class="comment">% Mean velocity value for the ZUPT window time</span>
        vel_m = mean (vel_e(i-idz:i , :));

        <span class="comment">% If mean velocity value is under the ZUPT threshold velocity...</span>
        <span class="keyword">if</span> (abs(vel_m) &lt; vor_dme.zupt_th)

            <span class="comment">% Current attitude is equal to the mean of previous attitudes</span>
            <span class="comment">% inside the ZUPT window time</span>
            roll_e(i)  = mean (roll_e(i-idz:i , :));
            pitch_e(i) = mean (pitch_e(i-idz:i , :));
            yaw_e(i)   = mean (yaw_e(i-idz:i , :));

            <span class="comment">% Current position is equal to the mean of previous positions</span>
            <span class="comment">% inside the ZUPT window time</span>
            lat_e(i) = mean (lat_e(i-idz:i , :));
            lon_e(i) = mean (lon_e(i-idz:i , :));
            h_e(i)   = mean (h_e(i-idz:i , :));

            <span class="comment">% Alternative attitude ZUPT correction</span>
            <span class="comment">% roll_e(i)  = (roll_e(i-idz , :));</span>
            <span class="comment">% pitch_e(i) = (pitch_e(i-idz , :));</span>
            <span class="comment">% yaw_e(i)   = (yaw_e(i-idz, :));</span>
            <span class="comment">% lat_e(i) = (lat_e(i-idz:i , :));</span>
            <span class="comment">% lon_e(i) = (lon_e(i-idz:i , :));</span>
            <span class="comment">% h_e(i)   = (h_e(i-idz:i , :));</span>

            zupt_flag = true;

            <span class="comment">% fprintf(' z\n')       % DEBUG</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre>
<h2 id="11">KALMAN FILTER UPDATE</h2>
<pre class="codeinput">    <span class="comment">% Check if there is a new vor_dme measurement to process at current INS time</span>
    gdx =  find (vor_dme.t &gt;= (imu.t(i) - vor_dme.eps) &amp; vor_dme.t &lt; (imu.t(i) + vor_dme.eps));

    <span class="keyword">if</span> ( ~isempty(gdx) &amp;&amp; gdx(1) &gt; 1)
</pre>
<pre class="codeinput">        gdx = gdx(1);
        <span class="comment">%  gdx       % DEBUG</span>
</pre>
<h2 id="13">MEASUREMENTS</h2>
<pre class="codeinput">        <span class="comment">%    For Debug:</span>
        <span class="comment">%</span>
        <span class="comment">% % VOR hatası hesaplaması</span>
        <span class="comment">% vor_error = vor_dme.distance(gdx) * tand(1);  % 1 derece VOR hatası</span>
        <span class="comment">%</span>
        <span class="comment">% H_dme = 0.137 * (317 * (1 - exp(-0.137 * -vor_dme.h(gdx))) / 0.137 - vor_dme.h(gdx));</span>
        <span class="comment">% dme_error = H_dme * vor_dme.distance(gdx) * csc(deg2rad(vor_dme.bearing(gdx)) );</span>
        <span class="comment">%</span>
        <span class="comment">% % Toplam hata standart sapması</span>
        <span class="comment">% total_error = sqrt(vor_error^2 + dme_error^2);</span>
        <span class="comment">%</span>
        <span class="comment">% % Hataları vekt&ouml;rlere ekleme</span>
        <span class="comment">% vor_errors(i) = vor_error;</span>
        <span class="comment">% dme_errors(i) = dme_error;</span>
        <span class="comment">% total_errors(i) = total_error;</span>


        <span class="comment">% Meridian and normal radii of curvature update</span>
        [RM,RN] = radius(lat_e(i));

        <span class="comment">% Radians-to-meters matrix</span>
        Tpr = diag([(RM + h_e(i)), (RN + h_e(i)) * cos(lat_e(i)), -1]);

        <span class="comment">% Position innovations in meters with lever arm correction</span>
        zp = Tpr * ([lat_e(i); lon_e(i); h_e(i);] - [vor_dme.lat(gdx); vor_dme.lon(gdx); vor_dme.h(gdx);]) <span class="keyword">...</span>
            + (DCMbn * vor_dme.larm);

        <span class="comment">% Velocity innovations with lever arm correction</span>
        zv = (vel_e(i,:) - vor_dme.vel(gdx,:) - ((omega_ie_n + omega_en_n) * (DCMbn * vor_dme.larm ))' <span class="keyword">...</span>
            + (DCMbn * skewm(wb_corrected) * vor_dme.larm )' )';
</pre>
<h2 id="14">KALMAN FILTER</h2>
<pre class="codeinput">        <span class="comment">% vor_dme sampling interval</span>
        dtg = vor_dme.t(gdx) - vor_dme.t(gdx-1);

        <span class="comment">% Vector to update matrix F</span>
        upd = [vel_e(i,:) lat_e(i) h_e(i) fn' wn'];

        <span class="comment">% Matrices F and G update</span>
        [kf.F, kf.G] = F_update(upd, DCMbn, imu);

        <span class="comment">% Matrix H update</span>
        <span class="keyword">if</span>(zupt_flag == false)
            kf.H = [ O I O O O ;
                O O Tpr O O ; ];
            kf.R = diag([vor_dme.stdv vor_dme.stdm]).^2;
            kf.z = [ zv' zp' ]';
        <span class="keyword">else</span>
            kf.H = [ O I O O O ; ];
            kf.R = diag([vor_dme.stdv]).^2;
            kf.z = zv;
        <span class="keyword">end</span>

        <span class="comment">% a posteriori states are forced to be zero (error-state approach)</span>
        kf.xp = zeros(n , 1);
        <span class="comment">% Execution of the extended Kalman filter</span>
        kf = kalman(kf, dtg);
</pre>
<h2 id="15">OBSERVABILITY</h2>
<pre class="codeinput">        <span class="comment">% Number the observable states at current vor_dme time</span>
        ob(gdx) = rank(obsv(kf.F, kf.H));
</pre>
<h2 id="16">INS/vor_dme CORRECTIONS</h2>
<pre class="codeinput">        <span class="comment">% Quaternion correction</span>
        qua_skew = -skewm(qua(1:3));    <span class="comment">% According to Crassidis, qua_skew should be</span>
                                        <span class="comment">% positive, but if positive NaveGo diverges.</span>
        <span class="comment">% Crassidis, Eq. A.174a</span>
        Xi = [qua(4)*eye(3) + qua_skew; -qua(1:3)'];

        <span class="comment">% Crassidis, Eq. 7.34</span>
        qua = qua + 0.5 .* Xi * kf.xp(1:3);
        qua = qua / norm(qua);          <span class="comment">% Brute-force normalization</span>

        <span class="comment">% DCM correction</span>
        DCMbn = qua2dcm(qua);

        <span class="comment">% Attitude correction, method 1</span>
        <span class="comment">%         euler = qua2euler(qua);</span>
        <span class="comment">%         roll_e(i) = euler(1);</span>
        <span class="comment">%         pitch_e(i)= euler(2);</span>
        <span class="comment">%         yaw_e(i)  = euler(3);</span>

        <span class="comment">% Attitude correction, method 2</span>
        roll_e(i)  = roll_e(i)  - kf.xp(1);
        pitch_e(i) = pitch_e(i) - kf.xp(2);
        yaw_e(i)   = yaw_e(i)   - kf.xp(3);

        <span class="comment">% Velocity correction</span>
        vel_e(i,1) = vel_e(i,1) - kf.xp(4);
        vel_e(i,2) = vel_e(i,2) - kf.xp(5);
        vel_e(i,3) = vel_e(i,3) - kf.xp(6);

        <span class="comment">% Position correction</span>
        lat_e(i) = lat_e(i) - kf.xp(7);
        lon_e(i) = lon_e(i) - kf.xp(8);
        h_e(i)   = h_e(i)   - kf.xp(9);

        <span class="comment">% Biases estimation</span>
        gb_dyn   = -kf.xp(10:12);
        ab_dyn   = -kf.xp(13:15);

        <span class="comment">% Matrices for later Kalman filter performance analysis</span>
        xi(gdx,:) = kf.xi';
        xp(gdx,:) = kf.xp';
        b(gdx,:) = [gb_dyn', ab_dyn'];
        A(gdx,:)  = reshape(kf.A,  1, n^2);
        Pi(gdx,:) = reshape(kf.Pi, 1, n^2);
        Pp(gdx,:) = reshape(kf.Pp, 1, n^2);

        <span class="keyword">if</span>(zupt_flag == false)
            v(gdx,:)  = kf.v';
            z(gdx,:)  = kf.z';
            K(gdx,:)  = reshape(kf.K, 1, n*r);
            S(gdx,:)  = reshape(kf.S, 1, r^2);
        <span class="keyword">else</span>
            zupt_flag = false;
            z(gdx,:)  = [ kf.z' 0 0 0 ]';
            v(gdx,:)  = [ kf.v' 0 0 0 ]';
            K(gdx,1:n*3) = reshape(kf.K, 1, n*3);
            S(gdx,1:9)  = reshape(kf.S, 1, 3^2);
        <span class="keyword">end</span>
</pre>
<pre class="codeinput">    <span class="keyword">end</span>
</pre>
<pre class="codeinput">
<span class="keyword">end</span>
</pre>
<h2 id="19">Summary from INS/vor_dme integration</h2>
<pre class="codeinput">nav_e.t     = imu.t(1:i, :);    <span class="comment">% INS time vector</span>
nav_e.tg    = vor_dme.t;           <span class="comment">% vor_dme time vector, which is the time vector when the Kalman filter was executed</span>
nav_e.roll  = roll_e(1:i, :);   <span class="comment">% Roll</span>
nav_e.pitch = pitch_e(1:i, :);  <span class="comment">% Pitch</span>
nav_e.yaw   = yaw_e(1:i, :);    <span class="comment">% Yaw</span>
nav_e.vel   = vel_e(1:i, :);    <span class="comment">% NED velocities</span>
nav_e.lat   = lat_e(1:i, :);    <span class="comment">% Latitude</span>
nav_e.lon   = lon_e(1:i, :);    <span class="comment">% Longitude</span>
nav_e.h     = h_e(1:i, :);      <span class="comment">% Altitude</span>
nav_e.gn    = gn_e(1:i, :);     <span class="comment">% Gravity estimation in the nav-frame.</span>

nav_e.xi    = xi;       <span class="comment">% A priori states</span>
nav_e.xp    = xp;       <span class="comment">% A posteriori states</span>
nav_e.z     = z;        <span class="comment">% INS/vor_dme measurements</span>
nav_e.v     = v;        <span class="comment">% Kalman filter innovations</span>
nav_e.b     = b;        <span class="comment">% Biases compensations</span>

nav_e.A     = A;        <span class="comment">% Transition matrices</span>
nav_e.Pi    = Pi;       <span class="comment">% A priori covariance matrices</span>
nav_e.Pp    = Pp;       <span class="comment">% A posteriori covariance matrices</span>
nav_e.K     = K;        <span class="comment">% Kalman gain matrices</span>
nav_e.S     = S;        <span class="comment">% Innovation matrices</span>
nav_e.ob    = ob;       <span class="comment">% Number of observable states after each vor_dme data arriving</span>

fprintf(<span class="string">'\n'</span>);
</pre>
<pre class="codeinput">
<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
function [nav_e] = ins_vor_dme(imu, vor_dme, att_mode)
% ins_vor_dme: loosely-coupled integrated navigation system.
%
% ins_vor_dme integrates IMU and vor_dme measurements by using an Extended Kalman filter.
%
% INPUT
%   imu, IMU data structure.
%         t: Ix1 time vector (seconds).
%        fb: Ix3 accelerations vector in body frame XYZ (m/s^2).
%        wb: Ix3 turn rates vector in body frame XYZ (radians/s).
%       arw: 1x3 angle random walks (rad/s/root-Hz).
%       vrw: 1x3 velocity random walks (m/s^2/root-Hz).
%     g_std: 1x3 gyros standard deviations (radians/s).
%     a_std: 1x3 accrs standard deviations (m/s^2).
%    gb_sta: 1x3 gyros static biases or turn-on biases (radians/s).
%    ab_sta: 1x3 accrs static biases or turn-on biases (m/s^2).
%    gb_dyn: 1x3 gyros dynamic biases or bias instabilities (radians/s).
%    ab_dyn: 1x3 accrs dynamic biases or bias instabilities (m/s^2).
%   gb_corr: 1x3 gyros correlation times (seconds).
%   ab_corr: 1x3 accrs correlation times (seconds).
%    gb_psd: 1x3 gyros dynamic biases root-PSD (rad/s/root-Hz).
%    ab_psd: 1x3 accrs dynamic biases root-PSD (m/s^2/root-Hz);
%      freq: 1x1 sampling frequency (Hz).
% ini_align: 1x3 initial attitude at t(1).
% ini_align_err: 1x3 initial attitude errors at t(1).
%
%   vor_dme, VOR/DME data structure.
%         t: Gx1 time vector (seconds).
%       lat: Gx1 latitude (radians).
%       lon: Gx1 longitude (radians).
%         h: Gx1 altitude (m).
%       vel: Gx3 NED velocities (m/s).
%       std: 1x3 position standard deviations (rad, rad, m).
%      stdm: 1x3 position standard deviations (m, m, m).
%      stdv: 1x3 velocity standard deviations (m/s).
%      larm: 3x1 lever arm from IMU to vor_dme antenna (x-fwd, y-right, z-down) (m).
%      freq: 1x1 sampling frequency (Hz).
%   zupt_th: 1x1 ZUPT threshold (m/s).
%  zupt_win: 1x1 ZUPT time window (seconds).
%       eps: 1x1 time interval to compare current IMU time to current vor_dme time vector (s).
%
%
%	vor_dme, vor_dme data structure.
%         t: Gx1 time vector (seconds).
%       lat: Gx1 latitude (radians).
%       lon: Gx1 longitude (radians).
%         h: Gx1 altitude (m).
%       vel: Gx3 NED velocities (m/s).
%       std: 1x3 position standard deviations (rad, rad, m).
%      stdm: 1x3 position standard deviations (m, m, m).
%      stdv: 1x3 velocity standard deviations (m/s).
%      larm: 3x1 lever arm from IMU to vor_dme antenna (x-fwd, y-right, z-down) (m).
%      freq: 1x1 sampling frequency (Hz).
%   zupt_th: 1x1 ZUPT threshold (m/s).
%  zupt_win: 1x1 ZUPT time window (seconds).
%       eps: 1x1 time interval to compare current IMU time to current vor_dme time vector (s).
%
%  att_mode: attitude mode string.
%      'quaternion': attitude updated in quaternion format. Default value.
%             'dcm': attitude updated in Direct Cosine Matrix format.
%
% OUTPUT
%   nav_e, INS/vor_dme navigation estimates data structure.
%         t: Ix1 INS time vector (seconds).
%        tg: Gx1 vor_dme time vector, when Kalman filter was executed (seconds).
%      roll: Ix1 roll (radians).
%     pitch: Ix1 pitch (radians).
%       yaw: Ix1 yaw (radians).
%       vel: Ix3 NED velocities (m/s).
%       lat: Ix1 latitude (radians).
%       lon: Ix1 longitude (radians).
%         h: Ix1 altitude (m).
%        xi: Gxn Kalman filter a priori states.
%        xp: Gxn Kalman filter a posteriori states.
%         z: Gxr INS/vor_dme measurements
%         v: Gxr Kalman filter innovations.
%         b: Gxr Kalman filter biases compensations, [gb_dyn ab_dyn].
%         A: Gxn^2 Kalman filter transition-state matrices, one matrix per
%            row ordered by columns.
%        Pp: Gxn^2 Kalman filter a posteriori covariance matrices, one
%         matrix per row ordered by columns.
%        Pi: Gxn^2 Kalman filter a priori covariance matrices, one matrix
%            per row ordered by columns.
%         K: Gx(n*r) Kalman gain matrices
%         S: Gxr^2 Innovation matrices
%        ob: Gx1 Number of observable states after each vor_dme data arriving



if nargin < 3, att_mode  = 'quaternion'; end

%% ZUPT ALGORITHM

zupt_flag = false;

%% PREALLOCATION

% Kalman filter dimensions
n = 15; % number of states
r = 6;  % number of sensors
% q = 12; % number of inputs

% Constant matrices
I = eye(3);
O = zeros(3);

% Length of INS time vector
LI = length(imu.t);

% Length of vor_dme time vector
LG = length(vor_dme.t);

% Preallocation of attitude vectors
roll_e  = zeros (LI, 1);
pitch_e = zeros (LI, 1);
yaw_e   = zeros (LI, 1);

% Preallocation of velocity vector
vel_e   = zeros (LI, 3);

% Preallocation of gravity vector
gn_e   = zeros (LI, 3);

% Preallocation of position vectors
lat_e    = zeros (LI, 1);
lon_e    = zeros (LI, 1);
h_e      = zeros (LI, 1);

% Preallocation of Kalman filter matrices for later performance analysis
xi = zeros(LG, n);      % Evolution of Kalman filter a priori states
xp = zeros(LG, n);      % Evolution of Kalman filter a posteriori states
z = zeros(LG, r);       % INS/vor_dme measurements
v = zeros(LG, r);       % Kalman filter innovations

A  = zeros(LG, n^2);    % Transition-state matrices
Pi = zeros(LG, n^2);    % A priori covariance matrices
Pp = zeros(LG, n^2);    % A posteriori covariance matrices
K  = zeros(LG, n*r);    % Kalman gain matrices
S  = zeros(LG, r^2);    % Innovation matrices
ob = zeros(LG, 1);      % Number of observable states at each vor_dme data arriving

b = zeros(LG, r);       % Biases compensantions after Kalman filter correction

%% INITIAL VALUES AT INS TIME = 1

% Initial attitude
roll_e(1)  = imu.ini_align(1);
pitch_e(1) = imu.ini_align(2);
yaw_e(1)   = imu.ini_align(3);
DCMnb = euler2dcm([roll_e(1); pitch_e(1); yaw_e(1);]);
DCMbn = DCMnb';
qua   = euler2qua([roll_e(1) pitch_e(1) yaw_e(1)]);

% Initial velocity
vel_e(1,:) = vor_dme.vel(1,:);

% Initial position
lat_e(1) = vor_dme.lat(1);
lon_e(1) = vor_dme.lon(1);
h_e(1)   = vor_dme.h(1);

% Initial dynamic biases
gb_dyn = imu.gb_dyn';
ab_dyn = imu.ab_dyn';

% Turn-rates update with both updated velocity and position
omega_ie_n = earth_rate(lat_e(1));
omega_en_n = transport_rate(lat_e(1), vel_e(1,1), vel_e(1,2), h_e(1));

% Gravity update
gn_e(1,:) = gravity(lat_e(1), h_e(1));

%% INITIALIZATION OF KALMAN FILTER MATRICES

% Prior estimates
kf.xi = [ zeros(1,9), imu.gb_dyn, imu.ab_dyn ]';  % Error vector state
kf.Pi = diag([imu.ini_align_err, vor_dme.stdv, vor_dme.std, imu.gb_dyn, imu.ab_dyn].^2);

kf.Q  = diag([imu.arw, imu.vrw, imu.gb_psd, imu.ab_psd].^2);
%kf.Q  = diag([imu.arw, imu.vrw, [0 0 0], [0 0 0]].^2);

fn = DCMbn * (imu.fb(1,:)' - ab_dyn - imu.ab_sta');
wn = DCMbn * (imu.wb(1,:)' - gb_dyn - imu.gb_sta');

% Vector to update matrix F
upd = [vor_dme.vel(1,:) vor_dme.lat(1) vor_dme.h(1) fn' wn'];

% Update matrices F and G
[kf.F, kf.G] = F_update(upd, DCMbn, imu);

[RM,RN] = radius(vor_dme.lat(1));
Tpr = diag([(RM + vor_dme.h(1)), (RN + vor_dme.h(1)) * cos(vor_dme.lat(1)), -1]);  % radians-to-meters

% Update matrix H
kf.H = [ O I O O O ; O O Tpr O O ; ];
kf.R = diag([vor_dme.stdv vor_dme.stdm]).^2;
kf.z = [ vor_dme.stdv, vor_dme.stdm ]';

% Propagate prior estimates to get xp(1) and Pp(1)
kf = kf_update( kf );

% Initial matrices for Kalman filter performance analysis
xi(1,:) = kf.xi';
xp(1,:) = kf.xp';
Pi(1,:) = reshape(kf.Pi, 1, n^2);
Pp(1,:) = reshape(kf.Pp, 1, n^2);
K(1,:)  = reshape(kf.K, 1, n*r);
S(1,:)  = reshape(kf.S, 1, r^2);
v(1,:)  = kf.v';
z(1,:)  = kf.z';
b(1,:) = [gb_dyn', ab_dyn'];

%% INS (IMU) TIME IS THE MASTER CLOCK
for i = 2:LI

    %% INERTIAL NAVIGATION SYSTEM (INS)

    % Print a dot on console every 10,000 INS executions
    if (mod(i,10000) == 0), fprintf('. ');  end
    % Print a return on console every 200,000 INS executions
    if (mod(i,200000) == 0), fprintf('\n'); end

    % IMU sampling interval
    dti = imu.t(i) - imu.t(i-1);

    % Inertial sensors corrected with a posteriori KF biases estimation and
    % deterministic static biases
    wb_corrected = imu.wb(i,:)' - gb_dyn - imu.gb_sta';
    fb_corrected = imu.fb(i,:)' - ab_dyn - imu.ab_sta';
    fn = DCMbn * fb_corrected;
    wn = DCMbn * wb_corrected;


    % Velocity update
    vel = vel_update(fn, vel_e(i-1,:), omega_ie_n, omega_en_n, gn_e(i-1,:)', dti);
    vel_e (i,:) = vel;

    % Position update
    pos = double(pos_update([lat_e(i-1) lon_e(i-1) h_e(i-1)], vel_e(i,:), dti));
    lat_e(i) = double(pos(1));
    lon_e(i) = double(pos(2));
    h_e(i)   = double(pos(3));

    % Turn-rates update with both updated velocity and position
    omega_ie_n = earth_rate(lat_e(i));
    omega_en_n = transport_rate(lat_e(i), vel_e(i,1), vel_e(i,2), h_e(i));

    % Gravity update
    gn_e(i,:) = gravity(lat_e(i), h_e(i));

    % Attitude update
    [qua, DCMbn, euler] = att_update(wb_corrected, DCMbn, qua, ...
        omega_ie_n, omega_en_n, dti, att_mode);
    roll_e(i) = euler(1);
    pitch_e(i)= euler(2);
    yaw_e(i)  = euler(3);

    %% ZUPT DETECTION ALGORITHM
    idz = floor( vor_dme.zupt_win / dti ); % Index to set ZUPT window time

    if ( i > idz )

        % Mean velocity value for the ZUPT window time
        vel_m = mean (vel_e(i-idz:i , :));

        % If mean velocity value is under the ZUPT threshold velocity...
        if (abs(vel_m) < vor_dme.zupt_th)

            % Current attitude is equal to the mean of previous attitudes
            % inside the ZUPT window time
            roll_e(i)  = mean (roll_e(i-idz:i , :));
            pitch_e(i) = mean (pitch_e(i-idz:i , :));
            yaw_e(i)   = mean (yaw_e(i-idz:i , :));

            % Current position is equal to the mean of previous positions
            % inside the ZUPT window time
            lat_e(i) = mean (lat_e(i-idz:i , :));
            lon_e(i) = mean (lon_e(i-idz:i , :));
            h_e(i)   = mean (h_e(i-idz:i , :));

            % Alternative attitude ZUPT correction
            % roll_e(i)  = (roll_e(i-idz , :));
            % pitch_e(i) = (pitch_e(i-idz , :));
            % yaw_e(i)   = (yaw_e(i-idz, :));
            % lat_e(i) = (lat_e(i-idz:i , :));
            % lon_e(i) = (lon_e(i-idz:i , :));
            % h_e(i)   = (h_e(i-idz:i , :));

            zupt_flag = true;

            % fprintf(' z\n')       % DEBUG
        end
    end

    %% KALMAN FILTER UPDATE

    % Check if there is a new vor_dme measurement to process at current INS time
    gdx =  find (vor_dme.t >= (imu.t(i) - vor_dme.eps) & vor_dme.t < (imu.t(i) + vor_dme.eps));

    if ( ~isempty(gdx) && gdx(1) > 1)

        gdx = gdx(1);
        %  gdx       % DEBUG

        %% MEASUREMENTS
        % 

        %    For Debug:
        % 
        % % VOR hatası hesaplaması
        % vor_error = vor_dme.distance(gdx) * tand(1);  % 1 derece VOR hatası
        % 
        % H_dme = 0.137 * (317 * (1 - exp(-0.137 * -vor_dme.h(gdx))) / 0.137 - vor_dme.h(gdx));
        % dme_error = H_dme * vor_dme.distance(gdx) * csc(deg2rad(vor_dme.bearing(gdx)) );
        % 
        % % Toplam hata standart sapması
        % total_error = sqrt(vor_error^2 + dme_error^2);
        % 
        % % Hataları vektörlere ekleme
        % vor_errors(i) = vor_error;
        % dme_errors(i) = dme_error;
        % total_errors(i) = total_error;

    
        % Meridian and normal radii of curvature update
        [RM,RN] = radius(lat_e(i));

        % Radians-to-meters matrix
        Tpr = diag([(RM + h_e(i)), (RN + h_e(i)) * cos(lat_e(i)), -1]);

        % Position innovations in meters with lever arm correction
        zp = Tpr * ([lat_e(i); lon_e(i); h_e(i);] - [vor_dme.lat(gdx); vor_dme.lon(gdx); vor_dme.h(gdx);]) ...
            + (DCMbn * vor_dme.larm);

        % Velocity innovations with lever arm correction
        zv = (vel_e(i,:) - vor_dme.vel(gdx,:) - ((omega_ie_n + omega_en_n) * (DCMbn * vor_dme.larm ))' ...
            + (DCMbn * skewm(wb_corrected) * vor_dme.larm )' )';

        %% KALMAN FILTER

        % vor_dme sampling interval
        dtg = vor_dme.t(gdx) - vor_dme.t(gdx-1);

        % Vector to update matrix F
        upd = [vel_e(i,:) lat_e(i) h_e(i) fn' wn'];

        % Matrices F and G update
        [kf.F, kf.G] = F_update(upd, DCMbn, imu);

        % Matrix H update
        if(zupt_flag == false)
            kf.H = [ O I O O O ;
                O O Tpr O O ; ];
            kf.R = diag([vor_dme.stdv vor_dme.stdm]).^2;
            kf.z = [ zv' zp' ]';
        else
            kf.H = [ O I O O O ; ];
            kf.R = diag([vor_dme.stdv]).^2;
            kf.z = zv;
        end

        % a posteriori states are forced to be zero (error-state approach)
        kf.xp = zeros(n , 1);
        % Execution of the extended Kalman filter
        kf = kalman(kf, dtg);

        %% OBSERVABILITY

        % Number the observable states at current vor_dme time
        ob(gdx) = rank(obsv(kf.F, kf.H));

        %% INS/vor_dme CORRECTIONS

        % Quaternion correction
        qua_skew = -skewm(qua(1:3));    % According to Crassidis, qua_skew should be
                                        % positive, but if positive NaveGo diverges.
        % Crassidis, Eq. A.174a
        Xi = [qua(4)*eye(3) + qua_skew; -qua(1:3)'];

        % Crassidis, Eq. 7.34
        qua = qua + 0.5 .* Xi * kf.xp(1:3);
        qua = qua / norm(qua);          % Brute-force normalization

        % DCM correction
        DCMbn = qua2dcm(qua);

        % Attitude correction, method 1
        %         euler = qua2euler(qua);
        %         roll_e(i) = euler(1);
        %         pitch_e(i)= euler(2);
        %         yaw_e(i)  = euler(3);

        % Attitude correction, method 2
        roll_e(i)  = roll_e(i)  - kf.xp(1);
        pitch_e(i) = pitch_e(i) - kf.xp(2);
        yaw_e(i)   = yaw_e(i)   - kf.xp(3);

        % Velocity correction
        vel_e(i,1) = vel_e(i,1) - kf.xp(4);
        vel_e(i,2) = vel_e(i,2) - kf.xp(5);
        vel_e(i,3) = vel_e(i,3) - kf.xp(6);

        % Position correction
        lat_e(i) = lat_e(i) - kf.xp(7);
        lon_e(i) = lon_e(i) - kf.xp(8);
        h_e(i)   = h_e(i)   - kf.xp(9);

        % Biases estimation
        gb_dyn   = -kf.xp(10:12);
        ab_dyn   = -kf.xp(13:15);

        % Matrices for later Kalman filter performance analysis
        xi(gdx,:) = kf.xi';
        xp(gdx,:) = kf.xp';
        b(gdx,:) = [gb_dyn', ab_dyn'];
        A(gdx,:)  = reshape(kf.A,  1, n^2);
        Pi(gdx,:) = reshape(kf.Pi, 1, n^2);
        Pp(gdx,:) = reshape(kf.Pp, 1, n^2);

        if(zupt_flag == false)
            v(gdx,:)  = kf.v';
            z(gdx,:)  = kf.z';
            K(gdx,:)  = reshape(kf.K, 1, n*r);
            S(gdx,:)  = reshape(kf.S, 1, r^2);
        else
            zupt_flag = false;
            z(gdx,:)  = [ kf.z' 0 0 0 ]';
            v(gdx,:)  = [ kf.v' 0 0 0 ]';
            K(gdx,1:n*3) = reshape(kf.K, 1, n*3);
            S(gdx,1:9)  = reshape(kf.S, 1, 3^2);
        end
    end
end

%% Summary from INS/vor_dme integration

nav_e.t     = imu.t(1:i, :);    % INS time vector
nav_e.tg    = vor_dme.t;           % vor_dme time vector, which is the time vector when the Kalman filter was executed
nav_e.roll  = roll_e(1:i, :);   % Roll
nav_e.pitch = pitch_e(1:i, :);  % Pitch
nav_e.yaw   = yaw_e(1:i, :);    % Yaw
nav_e.vel   = vel_e(1:i, :);    % NED velocities
nav_e.lat   = lat_e(1:i, :);    % Latitude
nav_e.lon   = lon_e(1:i, :);    % Longitude
nav_e.h     = h_e(1:i, :);      % Altitude
nav_e.gn    = gn_e(1:i, :);     % Gravity estimation in the nav-frame.

nav_e.xi    = xi;       % A priori states
nav_e.xp    = xp;       % A posteriori states
nav_e.z     = z;        % INS/vor_dme measurements
nav_e.v     = v;        % Kalman filter innovations
nav_e.b     = b;        % Biases compensations

nav_e.A     = A;        % Transition matrices
nav_e.Pi    = Pi;       % A priori covariance matrices
nav_e.Pp    = Pp;       % A posteriori covariance matrices
nav_e.K     = K;        % Kalman gain matrices
nav_e.S     = S;        % Innovation matrices
nav_e.ob    = ob;       % Number of observable states after each vor_dme data arriving

fprintf('\n');

end


##### SOURCE END #####
-->
</body>
</html>
